/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package k8s.io.api.storage.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

// CSIStorage represents information about storage provided by a certain CSI driver,
// like for example current capacity. As in CSIDriver, the name of the CSIStorage
// objects is the same as the driver name. Unlike CSIDriver, these objects are
// created dynamically and get updated regularly when there are changes.
message CSIStorage {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // The actual information may depend on the storage class and therefore
  // is provided separately for each storage class that uses the driver.
  //
  // +patchMergeKey=storageClassName
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=storageClassName
  repeated CSIStorageByClass info = 2;
}

// CSIStorageByClass contains information for one particular storage class
// of a CSI driver.
message CSIStorageByClass {
  // Storage class name, <all>, <ephemeral>.
  optional string storageClassName = 1;

  // A CSI driver may allocate storage from one or more pools with different
  // attributes. Entries must have unique names inside this list.
  //
  // +patchMergeKey=name
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=name
  repeated CSIStoragePool pools = 2;
}

// CSIStorageList is a collection of CSIStorage objects.
message CSIStorageList {
  // Standard list metadata
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // Items is the list of CSIStorage objects.
  // +listType=set
  repeated CSIStorage items = 2;
}

// CSIStoragePool identifies one particular storage pool and stores
// the corresponding attributes.
message CSIStoragePool {
  // The name is some user-friendly identifier for this entry.
  optional string name = 1;

  // NodeTopology can be used to describe a storage pool that is available
  // only for certain nodes in the cluster. If not set, the pool is consider
  // to be available from all nodes.
  // +optional
  optional k8s.io.api.core.v1.NodeSelector nodeTopology = 2;

  // Capacity is the size of the largest volume that currently can
  // be created. This is a best-effort guess and even volumes
  // of that size might not get created successfully.
  // +optional
  optional k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 3;

  // ExpiryTime is the absolute time at which this entry becomes obsolete.
  // When not set, the entry is valid forever.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time expiryTime = 4;
}

// VolumeAttachment captures the intent to attach or detach the specified volume
// to/from the specified node.
//
// VolumeAttachment objects are non-namespaced.
message VolumeAttachment {
  // Standard object metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Specification of the desired attach/detach volume behavior.
  // Populated by the Kubernetes system.
  optional VolumeAttachmentSpec spec = 2;

  // Status of the VolumeAttachment request.
  // Populated by the entity completing the attach or detach
  // operation, i.e. the external-attacher.
  // +optional
  optional VolumeAttachmentStatus status = 3;
}

// VolumeAttachmentList is a collection of VolumeAttachment objects.
message VolumeAttachmentList {
  // Standard list metadata
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // Items is the list of VolumeAttachments
  repeated VolumeAttachment items = 2;
}

// VolumeAttachmentSource represents a volume that should be attached.
// Right now only PersistenVolumes can be attached via external attacher,
// in future we may allow also inline volumes in pods.
// Exactly one member can be set.
message VolumeAttachmentSource {
  // Name of the persistent volume to attach.
  // +optional
  optional string persistentVolumeName = 1;

  // inlineVolumeSpec contains all the information necessary to attach
  // a persistent volume defined by a pod's inline VolumeSource. This field
  // is populated only for the CSIMigration feature. It contains
  // translated fields from a pod's inline VolumeSource to a
  // PersistentVolumeSpec. This field is alpha-level and is only
  // honored by servers that enabled the CSIMigration feature.
  // +optional
  optional k8s.io.api.core.v1.PersistentVolumeSpec inlineVolumeSpec = 2;
}

// VolumeAttachmentSpec is the specification of a VolumeAttachment request.
message VolumeAttachmentSpec {
  // Attacher indicates the name of the volume driver that MUST handle this
  // request. This is the name returned by GetPluginName().
  optional string attacher = 1;

  // Source represents the volume that should be attached.
  optional VolumeAttachmentSource source = 2;

  // The node that the volume should be attached to.
  optional string nodeName = 3;
}

// VolumeAttachmentStatus is the status of a VolumeAttachment request.
message VolumeAttachmentStatus {
  // Indicates the volume is successfully attached.
  // This field must only be set by the entity completing the attach
  // operation, i.e. the external-attacher.
  optional bool attached = 1;

  // Upon successful attach, this field is populated with any
  // information returned by the attach operation that must be passed
  // into subsequent WaitForAttach or Mount calls.
  // This field must only be set by the entity completing the attach
  // operation, i.e. the external-attacher.
  // +optional
  map<string, string> attachmentMetadata = 2;

  // The last error encountered during attach operation, if any.
  // This field must only be set by the entity completing the attach
  // operation, i.e. the external-attacher.
  // +optional
  optional VolumeError attachError = 3;

  // The last error encountered during detach operation, if any.
  // This field must only be set by the entity completing the detach
  // operation, i.e. the external-attacher.
  // +optional
  optional VolumeError detachError = 4;
}

// VolumeError captures an error encountered during a volume operation.
message VolumeError {
  // Time the error was encountered.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1;

  // String detailing the error encountered during Attach or Detach operation.
  // This string maybe logged, so it should not contain sensitive
  // information.
  // +optional
  optional string message = 2;
}

