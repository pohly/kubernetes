/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package k8s.io.client_go.applyconfigurations.core.v1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";
import "k8s.io/client-go/applyconfigurations/meta/v1/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "k8s.io/client-go/applyconfigurations/core/v1";

// AWSElasticBlockStoreVolumeSourceApplyConfiguration represents an declarative configuration of the AWSElasticBlockStoreVolumeSource type for use
// with apply.
message AWSElasticBlockStoreVolumeSourceApplyConfiguration {
  optional string volumeID = 1;

  optional string fsType = 2;

  optional int32 partition = 3;

  optional bool readOnly = 4;
}

// AffinityApplyConfiguration represents an declarative configuration of the Affinity type for use
// with apply.
message AffinityApplyConfiguration {
  optional NodeAffinityApplyConfiguration nodeAffinity = 1;

  optional PodAffinityApplyConfiguration podAffinity = 2;

  optional PodAntiAffinityApplyConfiguration podAntiAffinity = 3;
}

// AttachedVolumeApplyConfiguration represents an declarative configuration of the AttachedVolume type for use
// with apply.
message AttachedVolumeApplyConfiguration {
  optional string name = 1;

  optional string devicePath = 2;
}

// AzureDiskVolumeSourceApplyConfiguration represents an declarative configuration of the AzureDiskVolumeSource type for use
// with apply.
message AzureDiskVolumeSourceApplyConfiguration {
  optional string diskName = 1;

  optional string diskURI = 2;

  optional string cachingMode = 3;

  optional string fsType = 4;

  optional bool readOnly = 5;

  optional string kind = 6;
}

// AzureFilePersistentVolumeSourceApplyConfiguration represents an declarative configuration of the AzureFilePersistentVolumeSource type for use
// with apply.
message AzureFilePersistentVolumeSourceApplyConfiguration {
  optional string secretName = 1;

  optional string shareName = 2;

  optional bool readOnly = 3;

  optional string secretNamespace = 4;
}

// AzureFileVolumeSourceApplyConfiguration represents an declarative configuration of the AzureFileVolumeSource type for use
// with apply.
message AzureFileVolumeSourceApplyConfiguration {
  optional string secretName = 1;

  optional string shareName = 2;

  optional bool readOnly = 3;
}

// CSIPersistentVolumeSourceApplyConfiguration represents an declarative configuration of the CSIPersistentVolumeSource type for use
// with apply.
message CSIPersistentVolumeSourceApplyConfiguration {
  optional string driver = 1;

  optional string volumeHandle = 2;

  optional bool readOnly = 3;

  optional string fsType = 4;

  map<string, string> volumeAttributes = 5;

  optional SecretReferenceApplyConfiguration controllerPublishSecretRef = 6;

  optional SecretReferenceApplyConfiguration nodeStageSecretRef = 7;

  optional SecretReferenceApplyConfiguration nodePublishSecretRef = 8;

  optional SecretReferenceApplyConfiguration controllerExpandSecretRef = 9;

  optional SecretReferenceApplyConfiguration nodeExpandSecretRef = 10;
}

// CSIVolumeSourceApplyConfiguration represents an declarative configuration of the CSIVolumeSource type for use
// with apply.
message CSIVolumeSourceApplyConfiguration {
  optional string driver = 1;

  optional bool readOnly = 2;

  optional string fsType = 3;

  map<string, string> volumeAttributes = 4;

  optional LocalObjectReferenceApplyConfiguration nodePublishSecretRef = 5;
}

// CapabilitiesApplyConfiguration represents an declarative configuration of the Capabilities type for use
// with apply.
message CapabilitiesApplyConfiguration {
  repeated string add = 1;

  repeated string drop = 2;
}

// CephFSPersistentVolumeSourceApplyConfiguration represents an declarative configuration of the CephFSPersistentVolumeSource type for use
// with apply.
message CephFSPersistentVolumeSourceApplyConfiguration {
  repeated string monitors = 1;

  optional string path = 2;

  optional string user = 3;

  optional string secretFile = 4;

  optional SecretReferenceApplyConfiguration secretRef = 5;

  optional bool readOnly = 6;
}

// CephFSVolumeSourceApplyConfiguration represents an declarative configuration of the CephFSVolumeSource type for use
// with apply.
message CephFSVolumeSourceApplyConfiguration {
  repeated string monitors = 1;

  optional string path = 2;

  optional string user = 3;

  optional string secretFile = 4;

  optional LocalObjectReferenceApplyConfiguration secretRef = 5;

  optional bool readOnly = 6;
}

// CinderPersistentVolumeSourceApplyConfiguration represents an declarative configuration of the CinderPersistentVolumeSource type for use
// with apply.
message CinderPersistentVolumeSourceApplyConfiguration {
  optional string volumeID = 1;

  optional string fsType = 2;

  optional bool readOnly = 3;

  optional SecretReferenceApplyConfiguration secretRef = 4;
}

// CinderVolumeSourceApplyConfiguration represents an declarative configuration of the CinderVolumeSource type for use
// with apply.
message CinderVolumeSourceApplyConfiguration {
  optional string volumeID = 1;

  optional string fsType = 2;

  optional bool readOnly = 3;

  optional LocalObjectReferenceApplyConfiguration secretRef = 4;
}

// ClaimSourceApplyConfiguration represents an declarative configuration of the ClaimSource type for use
// with apply.
message ClaimSourceApplyConfiguration {
  optional string resourceClaimName = 1;

  optional string resourceClaimTemplateName = 2;
}

// ClientIPConfigApplyConfiguration represents an declarative configuration of the ClientIPConfig type for use
// with apply.
message ClientIPConfigApplyConfiguration {
  optional int32 timeoutSeconds = 1;
}

// ComponentConditionApplyConfiguration represents an declarative configuration of the ComponentCondition type for use
// with apply.
message ComponentConditionApplyConfiguration {
  optional string type = 1;

  optional string status = 2;

  optional string message = 3;

  optional string error = 4;
}

// ComponentStatusApplyConfiguration represents an declarative configuration of the ComponentStatus type for use
// with apply.
message ComponentStatusApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  repeated ComponentConditionApplyConfiguration conditions = 3;
}

// ConfigMapApplyConfiguration represents an declarative configuration of the ConfigMap type for use
// with apply.
message ConfigMapApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional bool immutable = 3;

  map<string, string> data = 4;

  map<string, bytes> binaryData = 5;
}

// ConfigMapEnvSourceApplyConfiguration represents an declarative configuration of the ConfigMapEnvSource type for use
// with apply.
message ConfigMapEnvSourceApplyConfiguration {
  optional LocalObjectReferenceApplyConfiguration localObjectReferenceApplyConfiguration = 1;

  optional bool optional = 2;
}

// ConfigMapKeySelectorApplyConfiguration represents an declarative configuration of the ConfigMapKeySelector type for use
// with apply.
message ConfigMapKeySelectorApplyConfiguration {
  optional LocalObjectReferenceApplyConfiguration localObjectReferenceApplyConfiguration = 1;

  optional string key = 2;

  optional bool optional = 3;
}

// ConfigMapNodeConfigSourceApplyConfiguration represents an declarative configuration of the ConfigMapNodeConfigSource type for use
// with apply.
message ConfigMapNodeConfigSourceApplyConfiguration {
  optional string namespace = 1;

  optional string name = 2;

  optional string uid = 3;

  optional string resourceVersion = 4;

  optional string kubeletConfigKey = 5;
}

// ConfigMapProjectionApplyConfiguration represents an declarative configuration of the ConfigMapProjection type for use
// with apply.
message ConfigMapProjectionApplyConfiguration {
  optional LocalObjectReferenceApplyConfiguration localObjectReferenceApplyConfiguration = 1;

  repeated KeyToPathApplyConfiguration items = 2;

  optional bool optional = 3;
}

// ConfigMapVolumeSourceApplyConfiguration represents an declarative configuration of the ConfigMapVolumeSource type for use
// with apply.
message ConfigMapVolumeSourceApplyConfiguration {
  optional LocalObjectReferenceApplyConfiguration localObjectReferenceApplyConfiguration = 1;

  repeated KeyToPathApplyConfiguration items = 2;

  optional int32 defaultMode = 3;

  optional bool optional = 4;
}

// ContainerApplyConfiguration represents an declarative configuration of the Container type for use
// with apply.
message ContainerApplyConfiguration {
  optional string name = 1;

  optional string image = 2;

  repeated string command = 3;

  repeated string args = 4;

  optional string workingDir = 5;

  repeated ContainerPortApplyConfiguration ports = 6;

  repeated EnvFromSourceApplyConfiguration envFrom = 7;

  repeated EnvVarApplyConfiguration env = 8;

  optional ResourceRequirementsApplyConfiguration resources = 9;

  repeated ContainerResizePolicyApplyConfiguration resizePolicy = 10;

  optional string restartPolicy = 11;

  repeated VolumeMountApplyConfiguration volumeMounts = 12;

  repeated VolumeDeviceApplyConfiguration volumeDevices = 13;

  optional ProbeApplyConfiguration livenessProbe = 14;

  optional ProbeApplyConfiguration readinessProbe = 15;

  optional ProbeApplyConfiguration startupProbe = 16;

  optional LifecycleApplyConfiguration lifecycle = 17;

  optional string terminationMessagePath = 18;

  optional string terminationMessagePolicy = 19;

  optional string imagePullPolicy = 20;

  optional SecurityContextApplyConfiguration securityContext = 21;

  optional bool stdin = 22;

  optional bool stdinOnce = 23;

  optional bool tty = 24;
}

// ContainerImageApplyConfiguration represents an declarative configuration of the ContainerImage type for use
// with apply.
message ContainerImageApplyConfiguration {
  repeated string names = 1;

  optional int64 sizeBytes = 2;
}

// ContainerPortApplyConfiguration represents an declarative configuration of the ContainerPort type for use
// with apply.
message ContainerPortApplyConfiguration {
  optional string name = 1;

  optional int32 hostPort = 2;

  optional int32 containerPort = 3;

  optional string protocol = 4;

  optional string hostIP = 5;
}

// ContainerResizePolicyApplyConfiguration represents an declarative configuration of the ContainerResizePolicy type for use
// with apply.
message ContainerResizePolicyApplyConfiguration {
  optional string resourceName = 1;

  optional string restartPolicy = 2;
}

// ContainerStateApplyConfiguration represents an declarative configuration of the ContainerState type for use
// with apply.
message ContainerStateApplyConfiguration {
  optional ContainerStateWaitingApplyConfiguration waiting = 1;

  optional ContainerStateRunningApplyConfiguration running = 2;

  optional ContainerStateTerminatedApplyConfiguration terminated = 3;
}

// ContainerStateRunningApplyConfiguration represents an declarative configuration of the ContainerStateRunning type for use
// with apply.
message ContainerStateRunningApplyConfiguration {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;
}

// ContainerStateTerminatedApplyConfiguration represents an declarative configuration of the ContainerStateTerminated type for use
// with apply.
message ContainerStateTerminatedApplyConfiguration {
  optional int32 exitCode = 1;

  optional int32 signal = 2;

  optional string reason = 3;

  optional string message = 4;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 5;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 6;

  optional string containerID = 7;
}

// ContainerStateWaitingApplyConfiguration represents an declarative configuration of the ContainerStateWaiting type for use
// with apply.
message ContainerStateWaitingApplyConfiguration {
  optional string reason = 1;

  optional string message = 2;
}

// ContainerStatusApplyConfiguration represents an declarative configuration of the ContainerStatus type for use
// with apply.
message ContainerStatusApplyConfiguration {
  optional string name = 1;

  optional ContainerStateApplyConfiguration state = 2;

  optional ContainerStateApplyConfiguration lastState = 3;

  optional bool ready = 4;

  optional int32 restartCount = 5;

  optional string image = 6;

  optional string imageID = 7;

  optional string containerID = 8;

  optional bool started = 9;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> allocatedResources = 10;

  optional ResourceRequirementsApplyConfiguration resources = 11;
}

// DaemonEndpointApplyConfiguration represents an declarative configuration of the DaemonEndpoint type for use
// with apply.
message DaemonEndpointApplyConfiguration {
  optional int32 Port = 1;
}

// DownwardAPIProjectionApplyConfiguration represents an declarative configuration of the DownwardAPIProjection type for use
// with apply.
message DownwardAPIProjectionApplyConfiguration {
  repeated DownwardAPIVolumeFileApplyConfiguration items = 1;
}

// DownwardAPIVolumeFileApplyConfiguration represents an declarative configuration of the DownwardAPIVolumeFile type for use
// with apply.
message DownwardAPIVolumeFileApplyConfiguration {
  optional string path = 1;

  optional ObjectFieldSelectorApplyConfiguration fieldRef = 2;

  optional ResourceFieldSelectorApplyConfiguration resourceFieldRef = 3;

  optional int32 mode = 4;
}

// DownwardAPIVolumeSourceApplyConfiguration represents an declarative configuration of the DownwardAPIVolumeSource type for use
// with apply.
message DownwardAPIVolumeSourceApplyConfiguration {
  repeated DownwardAPIVolumeFileApplyConfiguration items = 1;

  optional int32 defaultMode = 2;
}

// EmptyDirVolumeSourceApplyConfiguration represents an declarative configuration of the EmptyDirVolumeSource type for use
// with apply.
message EmptyDirVolumeSourceApplyConfiguration {
  optional string medium = 1;

  optional k8s.io.apimachinery.pkg.api.resource.Quantity sizeLimit = 2;
}

// EndpointAddressApplyConfiguration represents an declarative configuration of the EndpointAddress type for use
// with apply.
message EndpointAddressApplyConfiguration {
  optional string ip = 1;

  optional string hostname = 2;

  optional string nodeName = 3;

  optional ObjectReferenceApplyConfiguration targetRef = 4;
}

// EndpointPortApplyConfiguration represents an declarative configuration of the EndpointPort type for use
// with apply.
message EndpointPortApplyConfiguration {
  optional string name = 1;

  optional int32 port = 2;

  optional string protocol = 3;

  optional string appProtocol = 4;
}

// EndpointSubsetApplyConfiguration represents an declarative configuration of the EndpointSubset type for use
// with apply.
message EndpointSubsetApplyConfiguration {
  repeated EndpointAddressApplyConfiguration addresses = 1;

  repeated EndpointAddressApplyConfiguration notReadyAddresses = 2;

  repeated EndpointPortApplyConfiguration ports = 3;
}

// EndpointsApplyConfiguration represents an declarative configuration of the Endpoints type for use
// with apply.
message EndpointsApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  repeated EndpointSubsetApplyConfiguration subsets = 3;
}

// EnvFromSourceApplyConfiguration represents an declarative configuration of the EnvFromSource type for use
// with apply.
message EnvFromSourceApplyConfiguration {
  optional string prefix = 1;

  optional ConfigMapEnvSourceApplyConfiguration configMapRef = 2;

  optional SecretEnvSourceApplyConfiguration secretRef = 3;
}

// EnvVarApplyConfiguration represents an declarative configuration of the EnvVar type for use
// with apply.
message EnvVarApplyConfiguration {
  optional string name = 1;

  optional string value = 2;

  optional EnvVarSourceApplyConfiguration valueFrom = 3;
}

// EnvVarSourceApplyConfiguration represents an declarative configuration of the EnvVarSource type for use
// with apply.
message EnvVarSourceApplyConfiguration {
  optional ObjectFieldSelectorApplyConfiguration fieldRef = 1;

  optional ResourceFieldSelectorApplyConfiguration resourceFieldRef = 2;

  optional ConfigMapKeySelectorApplyConfiguration configMapKeyRef = 3;

  optional SecretKeySelectorApplyConfiguration secretKeyRef = 4;
}

// EphemeralContainerApplyConfiguration represents an declarative configuration of the EphemeralContainer type for use
// with apply.
message EphemeralContainerApplyConfiguration {
  optional EphemeralContainerCommonApplyConfiguration ephemeralContainerCommonApplyConfiguration = 1;

  optional string targetContainerName = 2;
}

// EphemeralContainerCommonApplyConfiguration represents an declarative configuration of the EphemeralContainerCommon type for use
// with apply.
message EphemeralContainerCommonApplyConfiguration {
  optional string name = 1;

  optional string image = 2;

  repeated string command = 3;

  repeated string args = 4;

  optional string workingDir = 5;

  repeated ContainerPortApplyConfiguration ports = 6;

  repeated EnvFromSourceApplyConfiguration envFrom = 7;

  repeated EnvVarApplyConfiguration env = 8;

  optional ResourceRequirementsApplyConfiguration resources = 9;

  repeated ContainerResizePolicyApplyConfiguration resizePolicy = 10;

  optional string restartPolicy = 11;

  repeated VolumeMountApplyConfiguration volumeMounts = 12;

  repeated VolumeDeviceApplyConfiguration volumeDevices = 13;

  optional ProbeApplyConfiguration livenessProbe = 14;

  optional ProbeApplyConfiguration readinessProbe = 15;

  optional ProbeApplyConfiguration startupProbe = 16;

  optional LifecycleApplyConfiguration lifecycle = 17;

  optional string terminationMessagePath = 18;

  optional string terminationMessagePolicy = 19;

  optional string imagePullPolicy = 20;

  optional SecurityContextApplyConfiguration securityContext = 21;

  optional bool stdin = 22;

  optional bool stdinOnce = 23;

  optional bool tty = 24;
}

// EphemeralVolumeSourceApplyConfiguration represents an declarative configuration of the EphemeralVolumeSource type for use
// with apply.
message EphemeralVolumeSourceApplyConfiguration {
  optional PersistentVolumeClaimTemplateApplyConfiguration volumeClaimTemplate = 1;
}

// EventApplyConfiguration represents an declarative configuration of the Event type for use
// with apply.
message EventApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional ObjectReferenceApplyConfiguration involvedObject = 3;

  optional string reason = 4;

  optional string message = 5;

  optional EventSourceApplyConfiguration source = 6;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time firstTimestamp = 7;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTimestamp = 8;

  optional int32 count = 9;

  optional string type = 10;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime eventTime = 11;

  optional EventSeriesApplyConfiguration series = 12;

  optional string action = 13;

  optional ObjectReferenceApplyConfiguration related = 14;

  optional string reportingComponent = 15;

  optional string reportingInstance = 16;
}

// EventSeriesApplyConfiguration represents an declarative configuration of the EventSeries type for use
// with apply.
message EventSeriesApplyConfiguration {
  optional int32 count = 1;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastObservedTime = 2;
}

// EventSourceApplyConfiguration represents an declarative configuration of the EventSource type for use
// with apply.
message EventSourceApplyConfiguration {
  optional string component = 1;

  optional string host = 2;
}

// ExecActionApplyConfiguration represents an declarative configuration of the ExecAction type for use
// with apply.
message ExecActionApplyConfiguration {
  repeated string command = 1;
}

// FCVolumeSourceApplyConfiguration represents an declarative configuration of the FCVolumeSource type for use
// with apply.
message FCVolumeSourceApplyConfiguration {
  repeated string targetWWNs = 1;

  optional int32 lun = 2;

  optional string fsType = 3;

  optional bool readOnly = 4;

  repeated string wwids = 5;
}

// FlexPersistentVolumeSourceApplyConfiguration represents an declarative configuration of the FlexPersistentVolumeSource type for use
// with apply.
message FlexPersistentVolumeSourceApplyConfiguration {
  optional string driver = 1;

  optional string fsType = 2;

  optional SecretReferenceApplyConfiguration secretRef = 3;

  optional bool readOnly = 4;

  map<string, string> options = 5;
}

// FlexVolumeSourceApplyConfiguration represents an declarative configuration of the FlexVolumeSource type for use
// with apply.
message FlexVolumeSourceApplyConfiguration {
  optional string driver = 1;

  optional string fsType = 2;

  optional LocalObjectReferenceApplyConfiguration secretRef = 3;

  optional bool readOnly = 4;

  map<string, string> options = 5;
}

// FlockerVolumeSourceApplyConfiguration represents an declarative configuration of the FlockerVolumeSource type for use
// with apply.
message FlockerVolumeSourceApplyConfiguration {
  optional string datasetName = 1;

  optional string datasetUUID = 2;
}

// GCEPersistentDiskVolumeSourceApplyConfiguration represents an declarative configuration of the GCEPersistentDiskVolumeSource type for use
// with apply.
message GCEPersistentDiskVolumeSourceApplyConfiguration {
  optional string pdName = 1;

  optional string fsType = 2;

  optional int32 partition = 3;

  optional bool readOnly = 4;
}

// GRPCActionApplyConfiguration represents an declarative configuration of the GRPCAction type for use
// with apply.
message GRPCActionApplyConfiguration {
  optional int32 port = 1;

  optional string service = 2;
}

// GitRepoVolumeSourceApplyConfiguration represents an declarative configuration of the GitRepoVolumeSource type for use
// with apply.
message GitRepoVolumeSourceApplyConfiguration {
  optional string repository = 1;

  optional string revision = 2;

  optional string directory = 3;
}

// GlusterfsPersistentVolumeSourceApplyConfiguration represents an declarative configuration of the GlusterfsPersistentVolumeSource type for use
// with apply.
message GlusterfsPersistentVolumeSourceApplyConfiguration {
  optional string endpoints = 1;

  optional string path = 2;

  optional bool readOnly = 3;

  optional string endpointsNamespace = 4;
}

// GlusterfsVolumeSourceApplyConfiguration represents an declarative configuration of the GlusterfsVolumeSource type for use
// with apply.
message GlusterfsVolumeSourceApplyConfiguration {
  optional string endpoints = 1;

  optional string path = 2;

  optional bool readOnly = 3;
}

// HTTPGetActionApplyConfiguration represents an declarative configuration of the HTTPGetAction type for use
// with apply.
message HTTPGetActionApplyConfiguration {
  optional string path = 1;

  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;

  optional string host = 3;

  optional string scheme = 4;

  repeated HTTPHeaderApplyConfiguration httpHeaders = 5;
}

// HTTPHeaderApplyConfiguration represents an declarative configuration of the HTTPHeader type for use
// with apply.
message HTTPHeaderApplyConfiguration {
  optional string name = 1;

  optional string value = 2;
}

// HostAliasApplyConfiguration represents an declarative configuration of the HostAlias type for use
// with apply.
message HostAliasApplyConfiguration {
  optional string ip = 1;

  repeated string hostnames = 2;
}

// HostIPApplyConfiguration represents an declarative configuration of the HostIP type for use
// with apply.
message HostIPApplyConfiguration {
  optional string ip = 1;
}

// HostPathVolumeSourceApplyConfiguration represents an declarative configuration of the HostPathVolumeSource type for use
// with apply.
message HostPathVolumeSourceApplyConfiguration {
  optional string path = 1;

  optional string type = 2;
}

// ISCSIPersistentVolumeSourceApplyConfiguration represents an declarative configuration of the ISCSIPersistentVolumeSource type for use
// with apply.
message ISCSIPersistentVolumeSourceApplyConfiguration {
  optional string targetPortal = 1;

  optional string iqn = 2;

  optional int32 lun = 3;

  optional string iscsiInterface = 4;

  optional string fsType = 5;

  optional bool readOnly = 6;

  repeated string portals = 7;

  optional bool chapAuthDiscovery = 8;

  optional bool chapAuthSession = 9;

  optional SecretReferenceApplyConfiguration secretRef = 10;

  optional string initiatorName = 11;
}

// ISCSIVolumeSourceApplyConfiguration represents an declarative configuration of the ISCSIVolumeSource type for use
// with apply.
message ISCSIVolumeSourceApplyConfiguration {
  optional string targetPortal = 1;

  optional string iqn = 2;

  optional int32 lun = 3;

  optional string iscsiInterface = 4;

  optional string fsType = 5;

  optional bool readOnly = 6;

  repeated string portals = 7;

  optional bool chapAuthDiscovery = 8;

  optional bool chapAuthSession = 9;

  optional LocalObjectReferenceApplyConfiguration secretRef = 10;

  optional string initiatorName = 11;
}

// KeyToPathApplyConfiguration represents an declarative configuration of the KeyToPath type for use
// with apply.
message KeyToPathApplyConfiguration {
  optional string key = 1;

  optional string path = 2;

  optional int32 mode = 3;
}

// LifecycleApplyConfiguration represents an declarative configuration of the Lifecycle type for use
// with apply.
message LifecycleApplyConfiguration {
  optional LifecycleHandlerApplyConfiguration postStart = 1;

  optional LifecycleHandlerApplyConfiguration preStop = 2;
}

// LifecycleHandlerApplyConfiguration represents an declarative configuration of the LifecycleHandler type for use
// with apply.
message LifecycleHandlerApplyConfiguration {
  optional ExecActionApplyConfiguration exec = 1;

  optional HTTPGetActionApplyConfiguration httpGet = 2;

  optional TCPSocketActionApplyConfiguration tcpSocket = 3;
}

// LimitRangeApplyConfiguration represents an declarative configuration of the LimitRange type for use
// with apply.
message LimitRangeApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional LimitRangeSpecApplyConfiguration spec = 3;
}

// LimitRangeItemApplyConfiguration represents an declarative configuration of the LimitRangeItem type for use
// with apply.
message LimitRangeItemApplyConfiguration {
  optional string type = 1;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> max = 2;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> min = 3;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> default = 4;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> defaultRequest = 5;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> maxLimitRequestRatio = 6;
}

// LimitRangeSpecApplyConfiguration represents an declarative configuration of the LimitRangeSpec type for use
// with apply.
message LimitRangeSpecApplyConfiguration {
  repeated LimitRangeItemApplyConfiguration limits = 1;
}

// LoadBalancerIngressApplyConfiguration represents an declarative configuration of the LoadBalancerIngress type for use
// with apply.
message LoadBalancerIngressApplyConfiguration {
  optional string ip = 1;

  optional string hostname = 2;

  optional string ipMode = 3;

  repeated PortStatusApplyConfiguration ports = 4;
}

// LoadBalancerStatusApplyConfiguration represents an declarative configuration of the LoadBalancerStatus type for use
// with apply.
message LoadBalancerStatusApplyConfiguration {
  repeated LoadBalancerIngressApplyConfiguration ingress = 1;
}

// LocalObjectReferenceApplyConfiguration represents an declarative configuration of the LocalObjectReference type for use
// with apply.
message LocalObjectReferenceApplyConfiguration {
  optional string name = 1;
}

// LocalVolumeSourceApplyConfiguration represents an declarative configuration of the LocalVolumeSource type for use
// with apply.
message LocalVolumeSourceApplyConfiguration {
  optional string path = 1;

  optional string fsType = 2;
}

// NFSVolumeSourceApplyConfiguration represents an declarative configuration of the NFSVolumeSource type for use
// with apply.
message NFSVolumeSourceApplyConfiguration {
  optional string server = 1;

  optional string path = 2;

  optional bool readOnly = 3;
}

// NamespaceApplyConfiguration represents an declarative configuration of the Namespace type for use
// with apply.
message NamespaceApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional NamespaceSpecApplyConfiguration spec = 3;

  optional NamespaceStatusApplyConfiguration status = 4;
}

// NamespaceConditionApplyConfiguration represents an declarative configuration of the NamespaceCondition type for use
// with apply.
message NamespaceConditionApplyConfiguration {
  optional string type = 1;

  optional string status = 2;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  optional string reason = 4;

  optional string message = 5;
}

// NamespaceSpecApplyConfiguration represents an declarative configuration of the NamespaceSpec type for use
// with apply.
message NamespaceSpecApplyConfiguration {
  repeated string finalizers = 1;
}

// NamespaceStatusApplyConfiguration represents an declarative configuration of the NamespaceStatus type for use
// with apply.
message NamespaceStatusApplyConfiguration {
  optional string phase = 1;

  repeated NamespaceConditionApplyConfiguration conditions = 2;
}

// NodeAddressApplyConfiguration represents an declarative configuration of the NodeAddress type for use
// with apply.
message NodeAddressApplyConfiguration {
  optional string type = 1;

  optional string address = 2;
}

// NodeAffinityApplyConfiguration represents an declarative configuration of the NodeAffinity type for use
// with apply.
message NodeAffinityApplyConfiguration {
  optional NodeSelectorApplyConfiguration requiredDuringSchedulingIgnoredDuringExecution = 1;

  repeated PreferredSchedulingTermApplyConfiguration preferredDuringSchedulingIgnoredDuringExecution = 2;
}

// NodeApplyConfiguration represents an declarative configuration of the Node type for use
// with apply.
message NodeApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional NodeSpecApplyConfiguration spec = 3;

  optional NodeStatusApplyConfiguration status = 4;
}

// NodeConditionApplyConfiguration represents an declarative configuration of the NodeCondition type for use
// with apply.
message NodeConditionApplyConfiguration {
  optional string type = 1;

  optional string status = 2;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastHeartbeatTime = 3;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

  optional string reason = 5;

  optional string message = 6;
}

// NodeConfigSourceApplyConfiguration represents an declarative configuration of the NodeConfigSource type for use
// with apply.
message NodeConfigSourceApplyConfiguration {
  optional ConfigMapNodeConfigSourceApplyConfiguration configMap = 1;
}

// NodeConfigStatusApplyConfiguration represents an declarative configuration of the NodeConfigStatus type for use
// with apply.
message NodeConfigStatusApplyConfiguration {
  optional NodeConfigSourceApplyConfiguration assigned = 1;

  optional NodeConfigSourceApplyConfiguration active = 2;

  optional NodeConfigSourceApplyConfiguration lastKnownGood = 3;

  optional string error = 4;
}

// NodeDaemonEndpointsApplyConfiguration represents an declarative configuration of the NodeDaemonEndpoints type for use
// with apply.
message NodeDaemonEndpointsApplyConfiguration {
  optional DaemonEndpointApplyConfiguration kubeletEndpoint = 1;
}

// NodeSelectorApplyConfiguration represents an declarative configuration of the NodeSelector type for use
// with apply.
message NodeSelectorApplyConfiguration {
  repeated NodeSelectorTermApplyConfiguration nodeSelectorTerms = 1;
}

// NodeSelectorRequirementApplyConfiguration represents an declarative configuration of the NodeSelectorRequirement type for use
// with apply.
message NodeSelectorRequirementApplyConfiguration {
  optional string key = 1;

  optional string operator = 2;

  repeated string values = 3;
}

// NodeSelectorTermApplyConfiguration represents an declarative configuration of the NodeSelectorTerm type for use
// with apply.
message NodeSelectorTermApplyConfiguration {
  repeated NodeSelectorRequirementApplyConfiguration matchExpressions = 1;

  repeated NodeSelectorRequirementApplyConfiguration matchFields = 2;
}

// NodeSpecApplyConfiguration represents an declarative configuration of the NodeSpec type for use
// with apply.
message NodeSpecApplyConfiguration {
  optional string podCIDR = 1;

  repeated string podCIDRs = 2;

  optional string providerID = 3;

  optional bool unschedulable = 4;

  repeated TaintApplyConfiguration taints = 5;

  optional NodeConfigSourceApplyConfiguration configSource = 6;

  optional string externalID = 7;
}

// NodeStatusApplyConfiguration represents an declarative configuration of the NodeStatus type for use
// with apply.
message NodeStatusApplyConfiguration {
  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> allocatable = 2;

  optional string phase = 3;

  repeated NodeConditionApplyConfiguration conditions = 4;

  repeated NodeAddressApplyConfiguration addresses = 5;

  optional NodeDaemonEndpointsApplyConfiguration daemonEndpoints = 6;

  optional NodeSystemInfoApplyConfiguration nodeInfo = 7;

  repeated ContainerImageApplyConfiguration images = 8;

  repeated string volumesInUse = 9;

  repeated AttachedVolumeApplyConfiguration volumesAttached = 10;

  optional NodeConfigStatusApplyConfiguration config = 11;
}

// NodeSystemInfoApplyConfiguration represents an declarative configuration of the NodeSystemInfo type for use
// with apply.
message NodeSystemInfoApplyConfiguration {
  optional string machineID = 1;

  optional string systemUUID = 2;

  optional string bootID = 3;

  optional string kernelVersion = 4;

  optional string osImage = 5;

  optional string containerRuntimeVersion = 6;

  optional string kubeletVersion = 7;

  optional string kubeProxyVersion = 8;

  optional string operatingSystem = 9;

  optional string architecture = 10;
}

// ObjectFieldSelectorApplyConfiguration represents an declarative configuration of the ObjectFieldSelector type for use
// with apply.
message ObjectFieldSelectorApplyConfiguration {
  optional string apiVersion = 1;

  optional string fieldPath = 2;
}

// ObjectReferenceApplyConfiguration represents an declarative configuration of the ObjectReference type for use
// with apply.
message ObjectReferenceApplyConfiguration {
  optional string kind = 1;

  optional string namespace = 2;

  optional string name = 3;

  optional string uid = 4;

  optional string apiVersion = 5;

  optional string resourceVersion = 6;

  optional string fieldPath = 7;
}

// PersistentVolumeApplyConfiguration represents an declarative configuration of the PersistentVolume type for use
// with apply.
message PersistentVolumeApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional PersistentVolumeSpecApplyConfiguration spec = 3;

  optional PersistentVolumeStatusApplyConfiguration status = 4;
}

// PersistentVolumeClaimApplyConfiguration represents an declarative configuration of the PersistentVolumeClaim type for use
// with apply.
message PersistentVolumeClaimApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional PersistentVolumeClaimSpecApplyConfiguration spec = 3;

  optional PersistentVolumeClaimStatusApplyConfiguration status = 4;
}

// PersistentVolumeClaimConditionApplyConfiguration represents an declarative configuration of the PersistentVolumeClaimCondition type for use
// with apply.
message PersistentVolumeClaimConditionApplyConfiguration {
  optional string type = 1;

  optional string status = 2;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

  optional string reason = 5;

  optional string message = 6;
}

// PersistentVolumeClaimSpecApplyConfiguration represents an declarative configuration of the PersistentVolumeClaimSpec type for use
// with apply.
message PersistentVolumeClaimSpecApplyConfiguration {
  repeated string accessModes = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.LabelSelectorApplyConfiguration selector = 2;

  optional ResourceRequirementsApplyConfiguration resources = 3;

  optional string volumeName = 4;

  optional string storageClassName = 5;

  optional string volumeMode = 6;

  optional TypedLocalObjectReferenceApplyConfiguration dataSource = 7;

  optional TypedObjectReferenceApplyConfiguration dataSourceRef = 8;
}

// PersistentVolumeClaimStatusApplyConfiguration represents an declarative configuration of the PersistentVolumeClaimStatus type for use
// with apply.
message PersistentVolumeClaimStatusApplyConfiguration {
  optional string phase = 1;

  repeated string accessModes = 2;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 3;

  repeated PersistentVolumeClaimConditionApplyConfiguration conditions = 4;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> allocatedResources = 5;

  map<string, string> allocatedResourceStatuses = 6;
}

// PersistentVolumeClaimTemplateApplyConfiguration represents an declarative configuration of the PersistentVolumeClaimTemplate type for use
// with apply.
message PersistentVolumeClaimTemplateApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 1;

  optional PersistentVolumeClaimSpecApplyConfiguration spec = 2;
}

// PersistentVolumeClaimVolumeSourceApplyConfiguration represents an declarative configuration of the PersistentVolumeClaimVolumeSource type for use
// with apply.
message PersistentVolumeClaimVolumeSourceApplyConfiguration {
  optional string claimName = 1;

  optional bool readOnly = 2;
}

// PersistentVolumeSourceApplyConfiguration represents an declarative configuration of the PersistentVolumeSource type for use
// with apply.
message PersistentVolumeSourceApplyConfiguration {
  optional GCEPersistentDiskVolumeSourceApplyConfiguration gcePersistentDisk = 1;

  optional AWSElasticBlockStoreVolumeSourceApplyConfiguration awsElasticBlockStore = 2;

  optional HostPathVolumeSourceApplyConfiguration hostPath = 3;

  optional GlusterfsPersistentVolumeSourceApplyConfiguration glusterfs = 4;

  optional NFSVolumeSourceApplyConfiguration nfs = 5;

  optional RBDPersistentVolumeSourceApplyConfiguration rbd = 6;

  optional ISCSIPersistentVolumeSourceApplyConfiguration iscsi = 7;

  optional CinderPersistentVolumeSourceApplyConfiguration cinder = 8;

  optional CephFSPersistentVolumeSourceApplyConfiguration cephfs = 9;

  optional FCVolumeSourceApplyConfiguration fc = 10;

  optional FlockerVolumeSourceApplyConfiguration flocker = 11;

  optional FlexPersistentVolumeSourceApplyConfiguration flexVolume = 12;

  optional AzureFilePersistentVolumeSourceApplyConfiguration azureFile = 13;

  optional VsphereVirtualDiskVolumeSourceApplyConfiguration vsphereVolume = 14;

  optional QuobyteVolumeSourceApplyConfiguration quobyte = 15;

  optional AzureDiskVolumeSourceApplyConfiguration azureDisk = 16;

  optional PhotonPersistentDiskVolumeSourceApplyConfiguration photonPersistentDisk = 17;

  optional PortworxVolumeSourceApplyConfiguration portworxVolume = 18;

  optional ScaleIOPersistentVolumeSourceApplyConfiguration scaleIO = 19;

  optional LocalVolumeSourceApplyConfiguration local = 20;

  optional StorageOSPersistentVolumeSourceApplyConfiguration storageos = 21;

  optional CSIPersistentVolumeSourceApplyConfiguration csi = 22;
}

// PersistentVolumeSpecApplyConfiguration represents an declarative configuration of the PersistentVolumeSpec type for use
// with apply.
message PersistentVolumeSpecApplyConfiguration {
  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;

  optional PersistentVolumeSourceApplyConfiguration persistentVolumeSourceApplyConfiguration = 2;

  repeated string accessModes = 3;

  optional ObjectReferenceApplyConfiguration claimRef = 4;

  optional string persistentVolumeReclaimPolicy = 5;

  optional string storageClassName = 6;

  repeated string mountOptions = 7;

  optional string volumeMode = 8;

  optional VolumeNodeAffinityApplyConfiguration nodeAffinity = 9;
}

// PersistentVolumeStatusApplyConfiguration represents an declarative configuration of the PersistentVolumeStatus type for use
// with apply.
message PersistentVolumeStatusApplyConfiguration {
  optional string phase = 1;

  optional string message = 2;

  optional string reason = 3;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastPhaseTransitionTime = 4;
}

// PhotonPersistentDiskVolumeSourceApplyConfiguration represents an declarative configuration of the PhotonPersistentDiskVolumeSource type for use
// with apply.
message PhotonPersistentDiskVolumeSourceApplyConfiguration {
  optional string pdID = 1;

  optional string fsType = 2;
}

// PodAffinityApplyConfiguration represents an declarative configuration of the PodAffinity type for use
// with apply.
message PodAffinityApplyConfiguration {
  repeated PodAffinityTermApplyConfiguration requiredDuringSchedulingIgnoredDuringExecution = 1;

  repeated WeightedPodAffinityTermApplyConfiguration preferredDuringSchedulingIgnoredDuringExecution = 2;
}

// PodAffinityTermApplyConfiguration represents an declarative configuration of the PodAffinityTerm type for use
// with apply.
message PodAffinityTermApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.LabelSelectorApplyConfiguration labelSelector = 1;

  repeated string namespaces = 2;

  optional string topologyKey = 3;

  optional k8s.io.client_go.applyconfigurations.meta.v1.LabelSelectorApplyConfiguration namespaceSelector = 4;
}

// PodAntiAffinityApplyConfiguration represents an declarative configuration of the PodAntiAffinity type for use
// with apply.
message PodAntiAffinityApplyConfiguration {
  repeated PodAffinityTermApplyConfiguration requiredDuringSchedulingIgnoredDuringExecution = 1;

  repeated WeightedPodAffinityTermApplyConfiguration preferredDuringSchedulingIgnoredDuringExecution = 2;
}

// PodApplyConfiguration represents an declarative configuration of the Pod type for use
// with apply.
message PodApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional PodSpecApplyConfiguration spec = 3;

  optional PodStatusApplyConfiguration status = 4;
}

// PodConditionApplyConfiguration represents an declarative configuration of the PodCondition type for use
// with apply.
message PodConditionApplyConfiguration {
  optional string type = 1;

  optional string status = 2;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

  optional string reason = 5;

  optional string message = 6;
}

// PodDNSConfigApplyConfiguration represents an declarative configuration of the PodDNSConfig type for use
// with apply.
message PodDNSConfigApplyConfiguration {
  repeated string nameservers = 1;

  repeated string searches = 2;

  repeated PodDNSConfigOptionApplyConfiguration options = 3;
}

// PodDNSConfigOptionApplyConfiguration represents an declarative configuration of the PodDNSConfigOption type for use
// with apply.
message PodDNSConfigOptionApplyConfiguration {
  optional string name = 1;

  optional string value = 2;
}

// PodIPApplyConfiguration represents an declarative configuration of the PodIP type for use
// with apply.
message PodIPApplyConfiguration {
  optional string ip = 1;
}

// PodOSApplyConfiguration represents an declarative configuration of the PodOS type for use
// with apply.
message PodOSApplyConfiguration {
  optional string name = 1;
}

// PodReadinessGateApplyConfiguration represents an declarative configuration of the PodReadinessGate type for use
// with apply.
message PodReadinessGateApplyConfiguration {
  optional string conditionType = 1;
}

// PodResourceClaimApplyConfiguration represents an declarative configuration of the PodResourceClaim type for use
// with apply.
message PodResourceClaimApplyConfiguration {
  optional string name = 1;

  optional ClaimSourceApplyConfiguration source = 2;
}

// PodResourceClaimStatusApplyConfiguration represents an declarative configuration of the PodResourceClaimStatus type for use
// with apply.
message PodResourceClaimStatusApplyConfiguration {
  optional string name = 1;

  optional string resourceClaimName = 2;
}

// PodSchedulingGateApplyConfiguration represents an declarative configuration of the PodSchedulingGate type for use
// with apply.
message PodSchedulingGateApplyConfiguration {
  optional string name = 1;
}

// PodSecurityContextApplyConfiguration represents an declarative configuration of the PodSecurityContext type for use
// with apply.
message PodSecurityContextApplyConfiguration {
  optional SELinuxOptionsApplyConfiguration seLinuxOptions = 1;

  optional WindowsSecurityContextOptionsApplyConfiguration windowsOptions = 2;

  optional int64 runAsUser = 3;

  optional int64 runAsGroup = 4;

  optional bool runAsNonRoot = 5;

  repeated int64 supplementalGroups = 6;

  optional int64 fsGroup = 7;

  repeated SysctlApplyConfiguration sysctls = 8;

  optional string fsGroupChangePolicy = 9;

  optional SeccompProfileApplyConfiguration seccompProfile = 10;
}

// PodSpecApplyConfiguration represents an declarative configuration of the PodSpec type for use
// with apply.
message PodSpecApplyConfiguration {
  repeated VolumeApplyConfiguration volumes = 1;

  repeated ContainerApplyConfiguration initContainers = 2;

  repeated ContainerApplyConfiguration containers = 3;

  repeated EphemeralContainerApplyConfiguration ephemeralContainers = 4;

  optional string restartPolicy = 5;

  optional int64 terminationGracePeriodSeconds = 6;

  optional int64 activeDeadlineSeconds = 7;

  optional string dnsPolicy = 8;

  map<string, string> nodeSelector = 9;

  optional string serviceAccountName = 10;

  optional string serviceAccount = 11;

  optional bool automountServiceAccountToken = 12;

  optional string nodeName = 13;

  optional bool hostNetwork = 14;

  optional bool hostPID = 15;

  optional bool hostIPC = 16;

  optional bool shareProcessNamespace = 17;

  optional PodSecurityContextApplyConfiguration securityContext = 18;

  repeated LocalObjectReferenceApplyConfiguration imagePullSecrets = 19;

  optional string hostname = 20;

  optional string subdomain = 21;

  optional AffinityApplyConfiguration affinity = 22;

  optional string schedulerName = 23;

  repeated TolerationApplyConfiguration tolerations = 24;

  repeated HostAliasApplyConfiguration hostAliases = 25;

  optional string priorityClassName = 26;

  optional int32 priority = 27;

  optional PodDNSConfigApplyConfiguration dnsConfig = 28;

  repeated PodReadinessGateApplyConfiguration readinessGates = 29;

  optional string runtimeClassName = 30;

  optional bool enableServiceLinks = 31;

  optional string preemptionPolicy = 32;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> overhead = 33;

  repeated TopologySpreadConstraintApplyConfiguration topologySpreadConstraints = 34;

  optional bool setHostnameAsFQDN = 35;

  optional PodOSApplyConfiguration os = 36;

  optional bool hostUsers = 37;

  repeated PodSchedulingGateApplyConfiguration schedulingGates = 38;

  repeated PodResourceClaimApplyConfiguration resourceClaims = 39;
}

// PodStatusApplyConfiguration represents an declarative configuration of the PodStatus type for use
// with apply.
message PodStatusApplyConfiguration {
  optional string phase = 1;

  repeated PodConditionApplyConfiguration conditions = 2;

  optional string message = 3;

  optional string reason = 4;

  optional string nominatedNodeName = 5;

  optional string hostIP = 6;

  repeated HostIPApplyConfiguration hostIPs = 7;

  optional string podIP = 8;

  repeated PodIPApplyConfiguration podIPs = 9;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 10;

  repeated ContainerStatusApplyConfiguration initContainerStatuses = 11;

  repeated ContainerStatusApplyConfiguration containerStatuses = 12;

  optional string qosClass = 13;

  repeated ContainerStatusApplyConfiguration ephemeralContainerStatuses = 14;

  optional string resize = 15;

  repeated PodResourceClaimStatusApplyConfiguration resourceClaimStatuses = 16;
}

// PodTemplateApplyConfiguration represents an declarative configuration of the PodTemplate type for use
// with apply.
message PodTemplateApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional PodTemplateSpecApplyConfiguration template = 3;
}

// PodTemplateSpecApplyConfiguration represents an declarative configuration of the PodTemplateSpec type for use
// with apply.
message PodTemplateSpecApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 1;

  optional PodSpecApplyConfiguration spec = 2;
}

// PortStatusApplyConfiguration represents an declarative configuration of the PortStatus type for use
// with apply.
message PortStatusApplyConfiguration {
  optional int32 port = 1;

  optional string protocol = 2;

  optional string error = 3;
}

// PortworxVolumeSourceApplyConfiguration represents an declarative configuration of the PortworxVolumeSource type for use
// with apply.
message PortworxVolumeSourceApplyConfiguration {
  optional string volumeID = 1;

  optional string fsType = 2;

  optional bool readOnly = 3;
}

// PreferredSchedulingTermApplyConfiguration represents an declarative configuration of the PreferredSchedulingTerm type for use
// with apply.
message PreferredSchedulingTermApplyConfiguration {
  optional int32 weight = 1;

  optional NodeSelectorTermApplyConfiguration preference = 2;
}

// ProbeApplyConfiguration represents an declarative configuration of the Probe type for use
// with apply.
message ProbeApplyConfiguration {
  optional ProbeHandlerApplyConfiguration probeHandlerApplyConfiguration = 1;

  optional int32 initialDelaySeconds = 2;

  optional int32 timeoutSeconds = 3;

  optional int32 periodSeconds = 4;

  optional int32 successThreshold = 5;

  optional int32 failureThreshold = 6;

  optional int64 terminationGracePeriodSeconds = 7;
}

// ProbeHandlerApplyConfiguration represents an declarative configuration of the ProbeHandler type for use
// with apply.
message ProbeHandlerApplyConfiguration {
  optional ExecActionApplyConfiguration exec = 1;

  optional HTTPGetActionApplyConfiguration httpGet = 2;

  optional TCPSocketActionApplyConfiguration tcpSocket = 3;

  optional GRPCActionApplyConfiguration grpc = 4;
}

// ProjectedVolumeSourceApplyConfiguration represents an declarative configuration of the ProjectedVolumeSource type for use
// with apply.
message ProjectedVolumeSourceApplyConfiguration {
  repeated VolumeProjectionApplyConfiguration sources = 1;

  optional int32 defaultMode = 2;
}

// QuobyteVolumeSourceApplyConfiguration represents an declarative configuration of the QuobyteVolumeSource type for use
// with apply.
message QuobyteVolumeSourceApplyConfiguration {
  optional string registry = 1;

  optional string volume = 2;

  optional bool readOnly = 3;

  optional string user = 4;

  optional string group = 5;

  optional string tenant = 6;
}

// RBDPersistentVolumeSourceApplyConfiguration represents an declarative configuration of the RBDPersistentVolumeSource type for use
// with apply.
message RBDPersistentVolumeSourceApplyConfiguration {
  repeated string monitors = 1;

  optional string image = 2;

  optional string fsType = 3;

  optional string pool = 4;

  optional string user = 5;

  optional string keyring = 6;

  optional SecretReferenceApplyConfiguration secretRef = 7;

  optional bool readOnly = 8;
}

// RBDVolumeSourceApplyConfiguration represents an declarative configuration of the RBDVolumeSource type for use
// with apply.
message RBDVolumeSourceApplyConfiguration {
  repeated string monitors = 1;

  optional string image = 2;

  optional string fsType = 3;

  optional string pool = 4;

  optional string user = 5;

  optional string keyring = 6;

  optional LocalObjectReferenceApplyConfiguration secretRef = 7;

  optional bool readOnly = 8;
}

// ReplicationControllerApplyConfiguration represents an declarative configuration of the ReplicationController type for use
// with apply.
message ReplicationControllerApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional ReplicationControllerSpecApplyConfiguration spec = 3;

  optional ReplicationControllerStatusApplyConfiguration status = 4;
}

// ReplicationControllerConditionApplyConfiguration represents an declarative configuration of the ReplicationControllerCondition type for use
// with apply.
message ReplicationControllerConditionApplyConfiguration {
  optional string type = 1;

  optional string status = 2;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  optional string reason = 4;

  optional string message = 5;
}

// ReplicationControllerSpecApplyConfiguration represents an declarative configuration of the ReplicationControllerSpec type for use
// with apply.
message ReplicationControllerSpecApplyConfiguration {
  optional int32 replicas = 1;

  optional int32 minReadySeconds = 2;

  map<string, string> selector = 3;

  optional PodTemplateSpecApplyConfiguration template = 4;
}

// ReplicationControllerStatusApplyConfiguration represents an declarative configuration of the ReplicationControllerStatus type for use
// with apply.
message ReplicationControllerStatusApplyConfiguration {
  optional int32 replicas = 1;

  optional int32 fullyLabeledReplicas = 2;

  optional int32 readyReplicas = 3;

  optional int32 availableReplicas = 4;

  optional int64 observedGeneration = 5;

  repeated ReplicationControllerConditionApplyConfiguration conditions = 6;
}

// ResourceClaimApplyConfiguration represents an declarative configuration of the ResourceClaim type for use
// with apply.
message ResourceClaimApplyConfiguration {
  optional string name = 1;
}

// ResourceFieldSelectorApplyConfiguration represents an declarative configuration of the ResourceFieldSelector type for use
// with apply.
message ResourceFieldSelectorApplyConfiguration {
  optional string containerName = 1;

  optional string resource = 2;

  optional k8s.io.apimachinery.pkg.api.resource.Quantity divisor = 3;
}

// ResourceQuotaApplyConfiguration represents an declarative configuration of the ResourceQuota type for use
// with apply.
message ResourceQuotaApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional ResourceQuotaSpecApplyConfiguration spec = 3;

  optional ResourceQuotaStatusApplyConfiguration status = 4;
}

// ResourceQuotaSpecApplyConfiguration represents an declarative configuration of the ResourceQuotaSpec type for use
// with apply.
message ResourceQuotaSpecApplyConfiguration {
  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;

  repeated string scopes = 2;

  optional ScopeSelectorApplyConfiguration scopeSelector = 3;
}

// ResourceQuotaStatusApplyConfiguration represents an declarative configuration of the ResourceQuotaStatus type for use
// with apply.
message ResourceQuotaStatusApplyConfiguration {
  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> used = 2;
}

// ResourceRequirementsApplyConfiguration represents an declarative configuration of the ResourceRequirements type for use
// with apply.
message ResourceRequirementsApplyConfiguration {
  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2;

  repeated ResourceClaimApplyConfiguration claims = 3;
}

// SELinuxOptionsApplyConfiguration represents an declarative configuration of the SELinuxOptions type for use
// with apply.
message SELinuxOptionsApplyConfiguration {
  optional string user = 1;

  optional string role = 2;

  optional string type = 3;

  optional string level = 4;
}

// ScaleIOPersistentVolumeSourceApplyConfiguration represents an declarative configuration of the ScaleIOPersistentVolumeSource type for use
// with apply.
message ScaleIOPersistentVolumeSourceApplyConfiguration {
  optional string gateway = 1;

  optional string system = 2;

  optional SecretReferenceApplyConfiguration secretRef = 3;

  optional bool sslEnabled = 4;

  optional string protectionDomain = 5;

  optional string storagePool = 6;

  optional string storageMode = 7;

  optional string volumeName = 8;

  optional string fsType = 9;

  optional bool readOnly = 10;
}

// ScaleIOVolumeSourceApplyConfiguration represents an declarative configuration of the ScaleIOVolumeSource type for use
// with apply.
message ScaleIOVolumeSourceApplyConfiguration {
  optional string gateway = 1;

  optional string system = 2;

  optional LocalObjectReferenceApplyConfiguration secretRef = 3;

  optional bool sslEnabled = 4;

  optional string protectionDomain = 5;

  optional string storagePool = 6;

  optional string storageMode = 7;

  optional string volumeName = 8;

  optional string fsType = 9;

  optional bool readOnly = 10;
}

// ScopeSelectorApplyConfiguration represents an declarative configuration of the ScopeSelector type for use
// with apply.
message ScopeSelectorApplyConfiguration {
  repeated ScopedResourceSelectorRequirementApplyConfiguration matchExpressions = 1;
}

// ScopedResourceSelectorRequirementApplyConfiguration represents an declarative configuration of the ScopedResourceSelectorRequirement type for use
// with apply.
message ScopedResourceSelectorRequirementApplyConfiguration {
  optional string scopeName = 1;

  optional string operator = 2;

  repeated string values = 3;
}

// SeccompProfileApplyConfiguration represents an declarative configuration of the SeccompProfile type for use
// with apply.
message SeccompProfileApplyConfiguration {
  optional string type = 1;

  optional string localhostProfile = 2;
}

// SecretApplyConfiguration represents an declarative configuration of the Secret type for use
// with apply.
message SecretApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional bool immutable = 3;

  map<string, bytes> data = 4;

  map<string, string> stringData = 5;

  optional string type = 6;
}

// SecretEnvSourceApplyConfiguration represents an declarative configuration of the SecretEnvSource type for use
// with apply.
message SecretEnvSourceApplyConfiguration {
  optional LocalObjectReferenceApplyConfiguration localObjectReferenceApplyConfiguration = 1;

  optional bool optional = 2;
}

// SecretKeySelectorApplyConfiguration represents an declarative configuration of the SecretKeySelector type for use
// with apply.
message SecretKeySelectorApplyConfiguration {
  optional LocalObjectReferenceApplyConfiguration localObjectReferenceApplyConfiguration = 1;

  optional string key = 2;

  optional bool optional = 3;
}

// SecretProjectionApplyConfiguration represents an declarative configuration of the SecretProjection type for use
// with apply.
message SecretProjectionApplyConfiguration {
  optional LocalObjectReferenceApplyConfiguration localObjectReferenceApplyConfiguration = 1;

  repeated KeyToPathApplyConfiguration items = 2;

  optional bool optional = 3;
}

// SecretReferenceApplyConfiguration represents an declarative configuration of the SecretReference type for use
// with apply.
message SecretReferenceApplyConfiguration {
  optional string name = 1;

  optional string namespace = 2;
}

// SecretVolumeSourceApplyConfiguration represents an declarative configuration of the SecretVolumeSource type for use
// with apply.
message SecretVolumeSourceApplyConfiguration {
  optional string secretName = 1;

  repeated KeyToPathApplyConfiguration items = 2;

  optional int32 defaultMode = 3;

  optional bool optional = 4;
}

// SecurityContextApplyConfiguration represents an declarative configuration of the SecurityContext type for use
// with apply.
message SecurityContextApplyConfiguration {
  optional CapabilitiesApplyConfiguration capabilities = 1;

  optional bool privileged = 2;

  optional SELinuxOptionsApplyConfiguration seLinuxOptions = 3;

  optional WindowsSecurityContextOptionsApplyConfiguration windowsOptions = 4;

  optional int64 runAsUser = 5;

  optional int64 runAsGroup = 6;

  optional bool runAsNonRoot = 7;

  optional bool readOnlyRootFilesystem = 8;

  optional bool allowPrivilegeEscalation = 9;

  optional string procMount = 10;

  optional SeccompProfileApplyConfiguration seccompProfile = 11;
}

// ServiceAccountApplyConfiguration represents an declarative configuration of the ServiceAccount type for use
// with apply.
message ServiceAccountApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  repeated ObjectReferenceApplyConfiguration secrets = 3;

  repeated LocalObjectReferenceApplyConfiguration imagePullSecrets = 4;

  optional bool automountServiceAccountToken = 5;
}

// ServiceAccountTokenProjectionApplyConfiguration represents an declarative configuration of the ServiceAccountTokenProjection type for use
// with apply.
message ServiceAccountTokenProjectionApplyConfiguration {
  optional string audience = 1;

  optional int64 expirationSeconds = 2;

  optional string path = 3;
}

// ServiceApplyConfiguration represents an declarative configuration of the Service type for use
// with apply.
message ServiceApplyConfiguration {
  optional k8s.io.client_go.applyconfigurations.meta.v1.TypeMetaApplyConfiguration typeMetaApplyConfiguration = 1;

  optional k8s.io.client_go.applyconfigurations.meta.v1.ObjectMetaApplyConfiguration metadata = 2;

  optional ServiceSpecApplyConfiguration spec = 3;

  optional ServiceStatusApplyConfiguration status = 4;
}

// ServicePortApplyConfiguration represents an declarative configuration of the ServicePort type for use
// with apply.
message ServicePortApplyConfiguration {
  optional string name = 1;

  optional string protocol = 2;

  optional string appProtocol = 3;

  optional int32 port = 4;

  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString targetPort = 5;

  optional int32 nodePort = 6;
}

// ServiceSpecApplyConfiguration represents an declarative configuration of the ServiceSpec type for use
// with apply.
message ServiceSpecApplyConfiguration {
  repeated ServicePortApplyConfiguration ports = 1;

  map<string, string> selector = 2;

  optional string clusterIP = 3;

  repeated string clusterIPs = 4;

  optional string type = 5;

  repeated string externalIPs = 6;

  optional string sessionAffinity = 7;

  optional string loadBalancerIP = 8;

  repeated string loadBalancerSourceRanges = 9;

  optional string externalName = 10;

  optional string externalTrafficPolicy = 11;

  optional int32 healthCheckNodePort = 12;

  optional bool publishNotReadyAddresses = 13;

  optional SessionAffinityConfigApplyConfiguration sessionAffinityConfig = 14;

  repeated string ipFamilies = 15;

  optional string ipFamilyPolicy = 16;

  optional bool allocateLoadBalancerNodePorts = 17;

  optional string loadBalancerClass = 18;

  optional string internalTrafficPolicy = 19;
}

// ServiceStatusApplyConfiguration represents an declarative configuration of the ServiceStatus type for use
// with apply.
message ServiceStatusApplyConfiguration {
  optional LoadBalancerStatusApplyConfiguration loadBalancer = 1;

  repeated k8s.io.client_go.applyconfigurations.meta.v1.ConditionApplyConfiguration conditions = 2;
}

// SessionAffinityConfigApplyConfiguration represents an declarative configuration of the SessionAffinityConfig type for use
// with apply.
message SessionAffinityConfigApplyConfiguration {
  optional ClientIPConfigApplyConfiguration clientIP = 1;
}

// StorageOSPersistentVolumeSourceApplyConfiguration represents an declarative configuration of the StorageOSPersistentVolumeSource type for use
// with apply.
message StorageOSPersistentVolumeSourceApplyConfiguration {
  optional string volumeName = 1;

  optional string volumeNamespace = 2;

  optional string fsType = 3;

  optional bool readOnly = 4;

  optional ObjectReferenceApplyConfiguration secretRef = 5;
}

// StorageOSVolumeSourceApplyConfiguration represents an declarative configuration of the StorageOSVolumeSource type for use
// with apply.
message StorageOSVolumeSourceApplyConfiguration {
  optional string volumeName = 1;

  optional string volumeNamespace = 2;

  optional string fsType = 3;

  optional bool readOnly = 4;

  optional LocalObjectReferenceApplyConfiguration secretRef = 5;
}

// SysctlApplyConfiguration represents an declarative configuration of the Sysctl type for use
// with apply.
message SysctlApplyConfiguration {
  optional string name = 1;

  optional string value = 2;
}

// TCPSocketActionApplyConfiguration represents an declarative configuration of the TCPSocketAction type for use
// with apply.
message TCPSocketActionApplyConfiguration {
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1;

  optional string host = 2;
}

// TaintApplyConfiguration represents an declarative configuration of the Taint type for use
// with apply.
message TaintApplyConfiguration {
  optional string key = 1;

  optional string value = 2;

  optional string effect = 3;

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time timeAdded = 4;
}

// TolerationApplyConfiguration represents an declarative configuration of the Toleration type for use
// with apply.
message TolerationApplyConfiguration {
  optional string key = 1;

  optional string operator = 2;

  optional string value = 3;

  optional string effect = 4;

  optional int64 tolerationSeconds = 5;
}

// TopologySelectorLabelRequirementApplyConfiguration represents an declarative configuration of the TopologySelectorLabelRequirement type for use
// with apply.
message TopologySelectorLabelRequirementApplyConfiguration {
  optional string key = 1;

  repeated string values = 2;
}

// TopologySelectorTermApplyConfiguration represents an declarative configuration of the TopologySelectorTerm type for use
// with apply.
message TopologySelectorTermApplyConfiguration {
  repeated TopologySelectorLabelRequirementApplyConfiguration matchLabelExpressions = 1;
}

// TopologySpreadConstraintApplyConfiguration represents an declarative configuration of the TopologySpreadConstraint type for use
// with apply.
message TopologySpreadConstraintApplyConfiguration {
  optional int32 maxSkew = 1;

  optional string topologyKey = 2;

  optional string whenUnsatisfiable = 3;

  optional k8s.io.client_go.applyconfigurations.meta.v1.LabelSelectorApplyConfiguration labelSelector = 4;

  optional int32 minDomains = 5;

  optional string nodeAffinityPolicy = 6;

  optional string nodeTaintsPolicy = 7;

  repeated string matchLabelKeys = 8;
}

// TypedLocalObjectReferenceApplyConfiguration represents an declarative configuration of the TypedLocalObjectReference type for use
// with apply.
message TypedLocalObjectReferenceApplyConfiguration {
  optional string apiGroup = 1;

  optional string kind = 2;

  optional string name = 3;
}

// TypedObjectReferenceApplyConfiguration represents an declarative configuration of the TypedObjectReference type for use
// with apply.
message TypedObjectReferenceApplyConfiguration {
  optional string apiGroup = 1;

  optional string kind = 2;

  optional string name = 3;

  optional string namespace = 4;
}

// VolumeApplyConfiguration represents an declarative configuration of the Volume type for use
// with apply.
message VolumeApplyConfiguration {
  optional string name = 1;

  optional VolumeSourceApplyConfiguration volumeSourceApplyConfiguration = 2;
}

// VolumeDeviceApplyConfiguration represents an declarative configuration of the VolumeDevice type for use
// with apply.
message VolumeDeviceApplyConfiguration {
  optional string name = 1;

  optional string devicePath = 2;
}

// VolumeMountApplyConfiguration represents an declarative configuration of the VolumeMount type for use
// with apply.
message VolumeMountApplyConfiguration {
  optional string name = 1;

  optional bool readOnly = 2;

  optional string mountPath = 3;

  optional string subPath = 4;

  optional string mountPropagation = 5;

  optional string subPathExpr = 6;
}

// VolumeNodeAffinityApplyConfiguration represents an declarative configuration of the VolumeNodeAffinity type for use
// with apply.
message VolumeNodeAffinityApplyConfiguration {
  optional NodeSelectorApplyConfiguration required = 1;
}

// VolumeProjectionApplyConfiguration represents an declarative configuration of the VolumeProjection type for use
// with apply.
message VolumeProjectionApplyConfiguration {
  optional SecretProjectionApplyConfiguration secret = 1;

  optional DownwardAPIProjectionApplyConfiguration downwardAPI = 2;

  optional ConfigMapProjectionApplyConfiguration configMap = 3;

  optional ServiceAccountTokenProjectionApplyConfiguration serviceAccountToken = 4;
}

// VolumeSourceApplyConfiguration represents an declarative configuration of the VolumeSource type for use
// with apply.
message VolumeSourceApplyConfiguration {
  optional HostPathVolumeSourceApplyConfiguration hostPath = 1;

  optional EmptyDirVolumeSourceApplyConfiguration emptyDir = 2;

  optional GCEPersistentDiskVolumeSourceApplyConfiguration gcePersistentDisk = 3;

  optional AWSElasticBlockStoreVolumeSourceApplyConfiguration awsElasticBlockStore = 4;

  optional GitRepoVolumeSourceApplyConfiguration gitRepo = 5;

  optional SecretVolumeSourceApplyConfiguration secret = 6;

  optional NFSVolumeSourceApplyConfiguration nfs = 7;

  optional ISCSIVolumeSourceApplyConfiguration iscsi = 8;

  optional GlusterfsVolumeSourceApplyConfiguration glusterfs = 9;

  optional PersistentVolumeClaimVolumeSourceApplyConfiguration persistentVolumeClaim = 10;

  optional RBDVolumeSourceApplyConfiguration rbd = 11;

  optional FlexVolumeSourceApplyConfiguration flexVolume = 12;

  optional CinderVolumeSourceApplyConfiguration cinder = 13;

  optional CephFSVolumeSourceApplyConfiguration cephfs = 14;

  optional FlockerVolumeSourceApplyConfiguration flocker = 15;

  optional DownwardAPIVolumeSourceApplyConfiguration downwardAPI = 16;

  optional FCVolumeSourceApplyConfiguration fc = 17;

  optional AzureFileVolumeSourceApplyConfiguration azureFile = 18;

  optional ConfigMapVolumeSourceApplyConfiguration configMap = 19;

  optional VsphereVirtualDiskVolumeSourceApplyConfiguration vsphereVolume = 20;

  optional QuobyteVolumeSourceApplyConfiguration quobyte = 21;

  optional AzureDiskVolumeSourceApplyConfiguration azureDisk = 22;

  optional PhotonPersistentDiskVolumeSourceApplyConfiguration photonPersistentDisk = 23;

  optional ProjectedVolumeSourceApplyConfiguration projected = 24;

  optional PortworxVolumeSourceApplyConfiguration portworxVolume = 25;

  optional ScaleIOVolumeSourceApplyConfiguration scaleIO = 26;

  optional StorageOSVolumeSourceApplyConfiguration storageos = 27;

  optional CSIVolumeSourceApplyConfiguration csi = 28;

  optional EphemeralVolumeSourceApplyConfiguration ephemeral = 29;
}

// VsphereVirtualDiskVolumeSourceApplyConfiguration represents an declarative configuration of the VsphereVirtualDiskVolumeSource type for use
// with apply.
message VsphereVirtualDiskVolumeSourceApplyConfiguration {
  optional string volumePath = 1;

  optional string fsType = 2;

  optional string storagePolicyName = 3;

  optional string storagePolicyID = 4;
}

// WeightedPodAffinityTermApplyConfiguration represents an declarative configuration of the WeightedPodAffinityTerm type for use
// with apply.
message WeightedPodAffinityTermApplyConfiguration {
  optional int32 weight = 1;

  optional PodAffinityTermApplyConfiguration podAffinityTerm = 2;
}

// WindowsSecurityContextOptionsApplyConfiguration represents an declarative configuration of the WindowsSecurityContextOptions type for use
// with apply.
message WindowsSecurityContextOptionsApplyConfiguration {
  optional string gmsaCredentialSpecName = 1;

  optional string gmsaCredentialSpec = 2;

  optional string runAsUserName = 3;

  optional bool hostProcess = 4;
}

